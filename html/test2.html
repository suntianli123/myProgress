<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<div>
    qwerty
</div>
</body>
<script>
    // 1、JS事件循环
    // JavaScript中的Event Loop(事件循环)机制，执行循序，
    // 先执行同步任务,之后执行异步任务，异步任务分类为宏任务(macro-task)和微任务(micro-task)
    // 宏任务：整体的Script setTimeout setInterval
    // 微任务：Promise process.nextTick
    // 反复执行以上步骤 就是事件循环(event loop)



    // 2、js原型详解
    // 每一个对象都有一个他的原型对象,他可以使用自己原型对象上的所以属性和方法
    // 获取原型方法：
    // 第一种：通过对象的__proto__获取
    // 第二种：通过构造函数protoType属性拿到原型

    // 第一种：__proto__
    // var a = {};
    // a.__proto__.name = '1111';
    // console.log(a.name)
    // // 第二种:protoType
    // function b(name){
    //     this.name = name
    // }
    // var bFun = new b('2222');
    // b.prototype.age = '19';
    // console.log(bFun);
    // console.log(bFun.age);

    // 继承,userA继承eFun里的属性
    // function eFun(word,passed){
    //     this.word = word;
    //     this.passed = passed;
    //     this.login = function(){
    //         console.log('登录')
    //     }
    // }
    // function userA(){
    //     this.deleteFun = function(){
    //         console.log('除去除去')
    //     }
    // }
    // userA.prototype = new eFun();
    // let newUserA = new userA();
    // newUserA.login();
    // 原型链：一个对象有原型，原型上还有原型


    // 3、vuex


    // 4、数据类型变为7种
    // string,Array,boolean,function,null,undefined,新增加Symbol函数
    // Symbol可以当成对象的属性名
    // 对象：key  value对
    // const sym = Symbol('abc');
    // console.log(sym);
    // const level = Symbol('level');
    // const student = {
    //     name:'小名',
    //     age:'11',
    //     [level]:'优秀'
    // }
    // console.log(student);
    // for(let key in student){
    //     console.log(key)
    // }
    // Symbol属性不能被for in获取


    // 5、this指向
    // console.log(this);
    // function aFun(){
    //     console.log(this);
    // }
    // aFun();
    // var b = {
    //     name:'12345',
    //     sayName(){
    //         console.log('我是' + this.name)
    //     }
    // };
    // b.sayName()

    // 6、call，apply,bind，   call，apply会调用函数，而bind作为返回值返回再调用
    // call是函数的方法，可以改变this指向的
    function fun(){
        console.log(this.name)
    }
    let cat = {
        name:'喵咪'
    }
    // fun.call(cat);
    // 或
    let dog = {
        name:'小狗',
        sayName(){
            console.log('这个小家伙名字叫:' + this.name)
        },
        eat(foot1,foot2){
            console.log('小家伙喜欢吃' + foot1 + '和' + foot2)
        }
    }
    // dog.sayName();
    // dog.sayName.call(cat);
    // dog.eat('骨头');
    dog.eat.call(cat,'鱼','肉');
    // apply
    dog.eat.apply(cat,['鱼','肉']);
    // bind 得赋值再调用
    let funBind = dog.eat.bind(cat,'鱼','肉');
    funBind();
</script>
<script src="https://ajax.aspnetcdn.com/ajax/jquery/jquery-3.5.1.min.js"></script>

</html>